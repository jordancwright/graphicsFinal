<html>
<meta charset="UTF-8"/>
<title>Cube Walking</title>

<link rel="stylesheet" type="text/css" href="cube_walking.css">

<!-- maps are stored in external files -->
<script type="notjs" id="map">
XXXXXXXXXXXXXXXXXXX
X        V        X
X L             L X
X     O     O     X
X                 X
X  O           O  X
X                 X
X     O     O     X
X                 X
XX               XX
XL               LX
XXXXXXXXXXXXXXXXXXX
</script>

<!-- include 3x3 matrix math library -->
<script src="lib/3d-math.js"></script>


<body>
<canvas id="c"></canvas>
<div id="ui"><table>
    <tr><td>Use arrow keys to move.</td></tr>
    <tr><td>fps: <span id="fps">-----</span></td></tr>
</table></div>
</body>

<!-- shaders to draw 2d crosshair -->


<script type="notjs" id="2d-vertex-shader">
    // an attribute will receive data from a buffer
    attribute vec4 a_position;

    void main() {
        // convert the position from pixels to 0.0 to 1.0
        gl_Position = a_position;
    }

</script>



<script type="notjs" id="2d-fragment-shader">
    // fragment shaders don't have a default precision so we need
    // to pick one. mediump is a good default. It means "medium precision"
    precision mediump float;

    void main() {
    // gl_FragColor is a special variable a fragment shader
        gl_FragColor = vec4(0, 1, 0, 1); // return redish-purple
    }
</script>

<script type="notjs" id="vertex-shader">
    precision mediump float;

    uniform mat4 u_matrixP;         // projection matrix    ( camera -> clip   )
    uniform mat4 u_matrixV;         // view matrix          (  world -> camera )
    uniform mat4 u_matrixM;         // model matrix         (  local -> world  )
    uniform mat4 u_matrixVit;       // inverse-transpose of view matrix
    uniform mat4 u_matrixMit;       // inverse-transpose of model matrix

    attribute vec3 a_pos_local;     // vert position in local space
    attribute vec3 a_norm_local;    // vert normal in local space
    attribute vec4 a_color;         // vert color

    varying vec3 v_pos_world;       // vert position in world space
    varying vec3 v_pos_camera;      // vert position in camera space
    varying vec3 v_norm_world;      // vert normal in world space
    varying vec3 v_norm_camera;     // vert normal in camera space
    varying vec4 v_color;           // vert color

    void main()
    {
        vec4 pw = u_matrixM * vec4(a_pos_local, 1);
        vec4 pc = u_matrixV * pw;
        vec3 nw = normalize((u_matrixMit * vec4(a_norm_local, 0)).xyz);
        vec3 nc = normalize((u_matrixVit * vec4(nw,           0)).xyz);

        gl_Position = u_matrixP * pc;

        v_pos_world   = pw.xyz / pw.w;
        v_pos_camera  = pc.xyz / pc.w;
        v_norm_world  = nw;
        v_norm_camera = nc;
        v_color       = a_color;
    }
</script>

<script type="notjs" id="fragment-shader">
    precision mediump float;

    // NOTE: MAXLIGHTS keyword will be replaced in javascript
    uniform vec3 u_light_pos[MAXLIGHTS];    // position of light
    uniform vec4 u_light_color[MAXLIGHTS];  // light color (rgb) and brightness (alpha)
    uniform vec4 u_light_ambient;           // ambient color (rgb) and brightness (alpha)
    uniform vec4 u_light_torch;             // simulate player holding a torch

    varying vec3 v_pos_world;   // vert position in world space
    varying vec3 v_pos_camera;  // vert position in camera space
    varying vec3 v_norm_world;  // vert normal in world space
    varying vec3 v_norm_camera; // vert normal in camera space
    varying vec4 v_color;       // vert color

    void main()
    {
        vec3 kd, ka, kt;

        // accumulate diffuse lighting
        kd = vec3(0,0,0);
        for(int i = 0; i < MAXLIGHTS; i++) {
            if(u_light_color[i].a > 0.0) {
                vec3  ldiff = u_light_pos[i] - v_pos_world;         // vector from fragment to light
                float ldist = length(ldiff);                        // distance from fragment to light
                vec3  ldir  = ldiff / ldist;                        // light direction (from fragment to light)
                float ndotl = max(0.0, dot(v_norm_world, ldir));    // fragment normal dot light direction
                kd += u_light_color[i].rgb * (u_light_color[i].a * ndotl / (ldist*ldist));
            }
        }

        // compute ambient lighting
        ka = u_light_ambient.rgb * u_light_ambient.a;

        // simulate torch
        float vdist = length(v_pos_camera);                     // distance from fragment to camera
        vec3  vdir  = -v_pos_camera / vdist;                    // view direction (from fragment to camera)
        float ndotl = max(0.0, dot(v_norm_camera, vdir));       // fragment normal dot light (view) direction
        kt = u_light_torch.rgb * (ndotl * u_light_torch.a / pow(vdist, 1.1));

        gl_FragColor = vec4(v_color.rgb * (kt + ka + kd), v_color.a);
    }
</script>




<script>
    const MAXLIGHTS = 8;
    const MAPLOAD = "map1";





    //////////////////////////////
    // set up webgl

    var canvas = document.getElementById("c");
    var gl = canvas.getContext("webgl", {antialias:true});

    gl.enable( gl.DEPTH_TEST );
    gl.depthFunc( gl.LESS );
    gl.enable( gl.CULL_FACE );
    gl.enable( gl.BLEND );
    gl.blendEquation( gl.FUNC_ADD );
    gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );

    var vertShaderSrc = document.getElementById("vertex-shader").text.replace(/MAXLIGHTS/g,MAXLIGHTS);
    var fragShaderSrc = document.getElementById("fragment-shader").text.replace(/MAXLIGHTS/g,MAXLIGHTS);
    var vertShader = createShader(gl, gl.VERTEX_SHADER,   vertShaderSrc);
    var fragShader = createShader(gl, gl.FRAGMENT_SHADER, fragShaderSrc);
    var program = createProgram(gl, vertShader, fragShader);
    gl.useProgram(program);




    var posLocation   = gl.getAttribLocation(program, "a_pos_local");
    var normLocation  = gl.getAttribLocation(program, "a_norm_local");
    var colorLocation = gl.getAttribLocation(program, "a_color");

    var matrixPLocation = gl.getUniformLocation(program, "u_matrixP");
    var matrixMLocation = gl.getUniformLocation(program, "u_matrixM");
    var matrixVLocation = gl.getUniformLocation(program, "u_matrixV");
    var matrixMitLocation  = gl.getUniformLocation(program, "u_matrixMit");
    var matrixVitLocation  = gl.getUniformLocation(program, "u_matrixVit");

    var lightPosLocations = [];
    var lightColLocations = [];
    for(var i = 0; i < MAXLIGHTS; i++) {
        lightPosLocations.push(gl.getUniformLocation(program, "u_light_pos[" + i + "]"));
        lightColLocations.push(gl.getUniformLocation(program, "u_light_color[" + i + "]"));
    }
    var lightAmbLocation = gl.getUniformLocation(program, "u_light_ambient");
    var lightTorLocation = gl.getUniformLocation(program, "u_light_torch");

    gl.enableVertexAttribArray(posLocation);
    gl.enableVertexAttribArray(normLocation);
    gl.enableVertexAttribArray(colorLocation);

    var TwoDVertShaderSrc = document.getElementById("2d-vertex-shader").innerHTML;
    var TwoDFragShaderSrc = document.getElementById("2d-fragment-shader").innerHTML;
    var TwoDVertShader = createShader(gl, gl.VERTEX_SHADER, TwoDVertShaderSrc);
    var TwoDFragShader = createShader(gl, gl.FRAGMENT_SHADER, TwoDFragShaderSrc);
    var TwoDProgram = createProgram2d(gl, TwoDVertShader, TwoDFragShader);


    gl.useProgram(TwoDProgram);
    var positionAttributeLocation2d = gl.getAttribLocation(TwoDProgram, "a_position");

    gl.enableVertexAttribArray(positionAttributeLocation2d);


    var positionBuffer2d = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer2d);

    var positions2d = [
        //top
    -0.007, 0.1,
    -0.007, 0.03,
    0.007, 0.03,
    -0.007, 0.1,
    0.007, 0.1,
    0.007, 0.03,
    //left
    -0.1, -0.007,
    -0.03, -0.007,
    -0.03, 0.007,
    -0.1, -0.007,
    -0.1, 0.007,
    -0.03, 0.007,
    //right
    0.1, -0.007,
    0.03, -0.007,
    0.03, 0.007,
    0.1, -0.007,
    0.1, 0.007,
    0.03, 0.007,
    //bottom
    -0.007, -0.1,
    -0.007, -0.03,
    0.007, -0.03,
    -0.007, -0.1,
    0.007, -0.1,
    0.007, -0.03,
    ];

    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions2d), gl.STATIC_DRAW);


    ///////////////////////////
    // game info

    // game states
    var prevTime = 0;
    var frames = 0, prevFramesTime = 0;
    var keysDown = [];
    var keys = { // see http://www.asquare.net/javascript/tests/KeyCode.html
        up:    38,
        down:  40,
        left:  37,
        right: 39,
    };
    var drawFloor = true, drawCeiling = true;

    // player and torch states
    var player = { loc:[0,0,0], fwdSpeed:0, dir:0, dirSpeed:0, fov:60, clip:[0.01,100] };
    var torch = { val: 1.0, range:[0.2,1.5], color:[1.0,0.7,0.4], blend:0.9 };


    // drawable objects
    var objectWall    = generateCubeObject(1.0);
    var objectTree    = generateCylinderObject(8, [0.2,0.5,0.2,1.0], false, 0.2, -1.0, 0.8);
    var objectTable   = generateCylinderObject(8, [0.7,0.7,0.7,1.0], false, 1.0, -1.0, -0.2);
    var objectLight   = generateCylinderObject(8, [0.7,1.0,0.7,1.0], false, 0.2,  0.9, 1.0);
    var objectFloor   = generateQuadObject([0,0,0], [0.7,0.7,0.7,1.0], [1,0,0], [0,0,1], [0, 1,0], 1);
    var objectCeiling = generateQuadObject([0,0,0], [0.5,0.5,0.5,1.0], [-1,0,0], [0,0,1], [0,-1,0], 1);


    ///////////////////////////
    // map stuff
    // x increases west-to-east, z increases north-to-south, and y increases floor-to-ceiling
    // player start    V : facing south, > : east, ^ : north, < : west
    // obstacle info   X : wall, O : cylinder, o : tree
    // lighting info   L : light

    var map = document.getElementById("map").text.split("\n");

    // convenient dictionaries for converting map symbols to drawable objects or player start directions
    var typeToObject = {
        "X": objectWall,
        "O": objectTable,
        "o": objectTree,
        "L": objectLight,
    };
    var typeToDirection = {
        "V": 0,
        ">": 1,
        "^": 2,
        "<": 3
    };
    var typeOfObstacles = ["X","O","o"];

    // gather info about map
    var mapSize = map.length;
    var drawables = []; // a list of drawable objects
    var lights = [];    // all the lights in the scene (up to MAXLIGHTS)
    for(var i = 0; i < map.length; i++) {
        var maprow = map[i];
        mapSize = Math.max(mapSize, maprow.length);
        for(var j = 0; j < maprow.length; j++) {
            var pos = [j*2, 0, i*2];

            // drawable objects
            if(maprow[j] in typeToObject) {
                drawables.push({
                    loc: pos,
                    type: maprow[j],
                    object: typeToObject[maprow[j]],
                });
            }

            // lights
            if(maprow[j] == "L") {
                if(lights.length < MAXLIGHTS) {
                    lights.push({
                        loc: [pos[0],0.88,pos[2]],
                        color: [1,1,1,2],
                    });
                } else {
                    console.log("too many lights!");
                }
            }

            // player start location and orientation
            if(maprow[j] in typeToDirection) {
                player.loc = pos;
                player.dir = typeToDirection[maprow[j]] * Math.PI / 2.0;
            }
        }
    }


    ///////////////////////////////////////////
    // game update and render

    requestAnimationFrame(update);

    function update(currTime)
    {
        currTime *= 0.001;
        var deltaTime = Math.min(currTime - prevTime, 0.25);
        prevTime = currTime;

        frames++;
        if(prevFramesTime == 0) prevFramesTime = currTime;
        if(frames > 100) {
            var framesTime = currTime - prevFramesTime;
            var fps = frames / framesTime;
            frames = 0;
            prevFramesTime = currTime;
            var fpsText = "" + Math.floor(fps * 100.0) / 100.0;
            fpsText += (fpsText.indexOf('.')==-1 ? '.' : '') + "000000";
            document.getElementById('fps').innerHTML = fpsText.slice(0,5);
        }

        // handle player movement
        if(keysDown.left) {
            player.dirSpeed += 15.0 * deltaTime;
        }
        if(keysDown.right) {
            player.dirSpeed -= 15.0 * deltaTime;
        }
        if(keysDown.up) {
            player.fwdSpeed += 40.0 * deltaTime;
        }
        if(keysDown.down) {
            player.fwdSpeed -= 40.0 * deltaTime;
        }
        player.loc[0] += player.fwdSpeed * Math.sin(player.dir) * deltaTime;
        player.loc[2] += player.fwdSpeed * Math.cos(player.dir) * deltaTime;
        player.dir += player.dirSpeed * deltaTime;
        player.fwdSpeed *= Math.pow(0.001, deltaTime);
        player.dirSpeed *= Math.pow(0.001, deltaTime);

        // check if player collides with obstacle
        var hitNorth = hitObstacle(player.loc[0], player.loc[1], player.loc[2] - 0.2);
        var hitSouth = hitObstacle(player.loc[0], player.loc[1], player.loc[2] + 0.2);
        var hitEast  = hitObstacle(player.loc[0] - 0.2, player.loc[1], player.loc[2]);
        var hitWest  = hitObstacle(player.loc[0] + 0.2, player.loc[1], player.loc[2]);
        if(hitNorth) {
            player.loc[2] = Math.round(player.loc[2]) + 0.2;
        }
        if(hitSouth) {
            player.loc[2] = Math.round(player.loc[2]) - 0.2;
        }
        if(hitEast) {
            player.loc[0] = Math.round(player.loc[0]) + 0.2;
        }
        if(hitWest) {
            player.loc[0] = Math.round(player.loc[0]) - 0.2;
        }
        // warning: the corner collision detection is not great
        var hitCorner = false;
        var hitOff = [0,0];
        var d = 0.141; // Math.sqrt((0.2*0.2) / 2)
        if(!hitNorth && !hitEast) {
            if(hitObstacle(player.loc[0]+d, player.loc[1], player.loc[2]-d)) {
                hitCorner = true;
                hitOff = [ d,-d];
            }
        }
        if(!hitNorth && !hitWest) {
            if(hitObstacle(player.loc[0]-d, player.loc[1], player.loc[2]-d)) {
                hitCorner = true;
                hitOff = [-d,-d];
            }
        }
        if(!hitSouth && !hitEast) {
            if(hitObstacle(player.loc[0]+d, player.loc[1], player.loc[2]+d)) {
                hitCorner = true;
                hitOff = [ d, d];
            }
        }
        if(!hitSouth && !hitWest) {
            if(hitObstacle(player.loc[0]-d, player.loc[1], player.loc[2]+d)) {
                hitCorner = true;
                hitOff = [-d, d];
            }
        }
        if(hitCorner) {
            var hx = Math.round(player.loc[0] + hitOff[0]), hz = Math.round(player.loc[2] + hitOff[1]);
            var dx = player.loc[0] - hx, dz = player.loc[2] - hz;
            var dl = Math.sqrt(dx*dx + dz*dz);
            player.loc[0] = hx + d * dx/dl;
            player.loc[2] = hz + d * dz/dl;
        }


        // resize and redraw the canvas!!
        resize(canvas);
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);


        gl.useProgram(program);
        var xformP    = m4.perspective(player.fov * Math.PI / 180.0, gl.canvas.width / gl.canvas.height, player.clip[0], player.clip[1]);
        // note: lookAt returns the inverse of the view xform matrix, so we need to invert
        var xformVinv = m4.lookAt(player.loc, [player.loc[0]+Math.sin(player.dir), player.loc[1], player.loc[2]+Math.cos(player.dir)], [0,1,0]);
        var xformV    = m4.inverse(xformVinv);

        gl.uniformMatrix4fv(matrixPLocation,   false, xformP);
        gl.uniformMatrix4fv(matrixVLocation,   false, xformV);
        gl.uniformMatrix4fv(matrixVitLocation, false, m4.transpose(xformVinv));

        for(var i = 0; i < lights.length; i++) {
            gl.uniform3fv(lightPosLocations[i], lights[i].loc);
            gl.uniform4fv(lightColLocations[i], lights[i].color);
        }

        gl.uniform4f(lightAmbLocation, 1.0, 1.0, 1.0, 0.02);

        var torchNew = torch.range[0] + (torch.range[1] - torch.range[0]) * Math.random();
        torch.val = torch.val * torch.blend + torchNew * (1.0 - torch.blend);
        gl.uniform4f(lightTorLocation, torch.color[0], torch.color[1], torch.color[2], torch.val);

        if(drawFloor)
        {
            var xformM = m4.translation(mapSize, -1, mapSize);
            xformM = m4.scale(xformM, mapSize, mapSize, mapSize);
            var xformMinv = m4.identity(); // ignore scaling and translation
            gl.uniformMatrix4fv(matrixMLocation,   false, xformM);
            gl.uniformMatrix4fv(matrixMitLocation, false, m4.transpose(xformMinv));
            drawObject(objectFloor);
        }

        if(drawCeiling)
        {
            var xformM = m4.translation(mapSize, 1, mapSize);
            xformM = m4.scale(xformM, mapSize, mapSize, mapSize);
            var xformMinv = m4.identity(); // ignore scaling and translation
            gl.uniformMatrix4fv(matrixMLocation,   false, xformM);
            gl.uniformMatrix4fv(matrixMitLocation, false, m4.transpose(xformMinv));
            drawObject(objectCeiling);
        }

        // draw *all* drawable objects (not terribly efficient!)
        for(i = 0; i < drawables.length; i++) {
            var drawable = drawables[i];
            // calculate transformation and its inverse
            var xformM    = m4.translation( drawable.loc[0],  drawable.loc[1],  drawable.loc[2]);
            var xformMinv = m4.translation(-drawable.loc[0], -drawable.loc[1], -drawable.loc[2]);
            gl.uniformMatrix4fv(matrixMLocation,   false, xformM);
            gl.uniformMatrix4fv(matrixMitLocation, false, m4.transpose(xformMinv));
            drawObject(drawable.object);
        }

		//crosshair starts here
		gl.disable( gl.DEPTH_TEST );
        gl.disable( gl.CULL_FACE );


        gl.useProgram(TwoDProgram);

        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer2d);

        var size = 2;          // 2 components per iteration
        var type = gl.FLOAT;   // the data is 32bit floats
        var normalize = false; // don't normalize the data
        var stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position
        var offset = 0;        // start at the beginning of the buffer
        gl.vertexAttribPointer(positionAttributeLocation2d, size, type, normalize, stride, offset);

        var primitiveType = gl.TRIANGLES;
        var offset = 0;
        var count = 24;
        gl.drawArrays(primitiveType, offset, count);


		gl.enable( gl.DEPTH_TEST );
        gl.enable( gl.CULL_FACE );

        requestAnimationFrame(update);
    }

    function hitObstacle(x,y,z)
    {
        var i = Math.round(z/2), j = Math.round(x/2);
        if(i < 0 || j < 0 || i >= map.length || j >= map[i].length) return false;
        return typeOfObstacles.indexOf(map[i][j]) != -1;
    }

    function drawObject(object)
    {
        // setup position buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, object.posBuffer);
        var size = 3;
        var type = gl.FLOAT;
        var normalize = false;
        var stride = 0;
        var offset = 0;
        gl.vertexAttribPointer(posLocation, size, type, normalize, stride, offset);

        // setup normal buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, object.normBuffer);
        var size = 3;
        var type = gl.FLOAT;
        var normalize = true;
        var stride = 0;
        var offset = 0;
        gl.vertexAttribPointer(normLocation, size, type, normalize, stride, offset);

        // setup color buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, object.colorBuffer);
        var size = 4;
        var type = gl.FLOAT;
        var normalize = false;
        var stride = 0;
        var offset = 0;
        gl.vertexAttribPointer(colorLocation, size, type, normalize, stride, offset);

        // draw the triangles!
        var primitiveType = gl.TRIANGLES;
        var offset = 0;
        gl.drawArrays(primitiveType, offset, object.length);
    }


    /////////////////////////////////////
    // generator helper functions

    function generateCubeObject(s)
    {
        var posBuffer   = gl.createBuffer();
        var normBuffer  = gl.createBuffer();
        var colorBuffer = gl.createBuffer();

        gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -s, -s, -s,   -s,  s, -s,    s, -s, -s, // north face
             s, -s, -s,   -s,  s, -s,    s,  s, -s,
            -s, -s,  s,    s, -s,  s,   -s,  s,  s, // south face
             s, -s,  s,    s,  s,  s,   -s,  s,  s,
            -s, -s, -s,   -s, -s,  s,   -s,  s, -s, // west face
            -s,  s, -s,   -s, -s,  s,   -s,  s,  s,
             s, -s, -s,    s,  s, -s,    s, -s,  s, // east face
             s,  s, -s,    s,  s,  s,    s, -s,  s,
            ]), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, normBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
             0,  0, -1,    0,  0, -1,    0,  0, -1, // north face
             0,  0, -1,    0,  0, -1,    0,  0, -1,
             0,  0,  1,    0,  0,  1,    0,  0,  1, // south face
             0,  0,  1,    0,  0,  1,    0,  0,  1,
            -1,  0,  0,   -1,  0,  0,   -1,  0,  0, // west face
            -1,  0,  0,   -1,  0,  0,   -1,  0,  0,
             1,  0,  0,    1,  0,  0,    1,  0,  0, // east face
             1,  0,  0,    1,  0,  0,    1,  0,  0,
            ]), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            1, 0, 0, 1,   1, 0, 0, 1,   1, 0, 0, 1, // north face
            1, 0, 0, 1,   1, 0, 0, 1,   1, 0, 0, 1,
            0, 1, 0, 1,   0, 1, 0, 1,   0, 1, 0, 1, // south face
            0, 1, 0, 1,   0, 1, 0, 1,   0, 1, 0, 1,
            0, 0, 1, 1,   0, 0, 1, 1,   0, 0, 1, 1, // west face
            0, 0, 1, 1,   0, 0, 1, 1,   0, 0, 1, 1,
            1, 0, 1, 1,   1, 0, 1, 1,   1, 0, 1, 1, // east face
            1, 0, 1, 1,   1, 0, 1, 1,   1, 0, 1, 1,
            ]), gl.STATIC_DRAW);

        return {
            posBuffer: posBuffer,
            normBuffer: normBuffer,
            colorBuffer: colorBuffer,
            length: 6*4,
        };
    }

    function generateQuadObject(loc, color, u, v, norm, size)
    {
        var posBuffer   = gl.createBuffer();
        var normBuffer  = gl.createBuffer();
        var colorBuffer = gl.createBuffer();

        var x = loc[0], y = loc[1], z = loc[2];
        var ux = u[0]*size, uy = u[1]*size, uz = u[2]*size;
        var vx = v[0]*size, vy = v[1]*size, vz = v[2]*size;

        var x0 = x - ux - vx, y0 = y - uy - vy, z0 = z - uz - vz;
        var x1 = x + ux - vx, y1 = y + uy - vy, z1 = z + uz - vz;
        var x2 = x + ux + vx, y2 = y + uy + vy, z2 = z + uz + vz;
        var x3 = x - ux + vx, y3 = y - uy + vy, z3 = z - uz + vz;

        var nx = norm[0], ny = norm[1], nz = norm[2];
        var r = color[0], g = color[1], b = color[2], a = color[3];

        gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            x0, y0, z0,   x3, y3, z3,   x1, y1, z1,
            x3, y3, z3,   x2, y2, z2,   x1, y1, z1,
            ]), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, normBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            nx, ny, nz,   nx, ny, nz,   nx, ny, nz,
            nx, ny, nz,   nx, ny, nz,   nx, ny, nz,
            ]), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            r,g,b,a,   r,g,b,a,   r,g,b,a,
            r,g,b,a,   r,g,b,a,   r,g,b,a,
            ]), gl.STATIC_DRAW);

        return {
            posBuffer: posBuffer,
            normBuffer: normBuffer,
            colorBuffer: colorBuffer,
            length: 6,
        };
    }

    function generateCrosshair()
    {

    }

    function generateCylinderObject(count, color, smooth, r, y0, y1)
    {
        var posBuffer   = gl.createBuffer();
        var normBuffer  = gl.createBuffer();
        var colorBuffer = gl.createBuffer();

        var p = [];
        var n = [];
        var c = [];

        for(var i = 0; i < count; i++)
        {
            var r0 = (i + 0.0) / count * Math.PI * 2.0;
            var r1 = (i + 1.0) / count * Math.PI * 2.0;
            var rn = (i + 0.5) / count * Math.PI * 2.0;
            var x0 = Math.cos(r0), z0 = Math.sin(r0);
            var x1 = Math.cos(r1), z1 = Math.sin(r1);
            var xn = Math.cos(rn), zn = Math.sin(rn);

            // side 1/2
            p.push(x0*r, y0, z0*r);
            if(smooth) n.push(x0,0,z0); else n.push(xn,0,zn);
            c.push(color[0], color[1], color[2], color[3]);

            p.push(x0*r, y1, z0*r);
            if(smooth) n.push(x0,0,z0); else n.push(xn,0,zn);
            c.push(color[0], color[1], color[2], color[3]);

            p.push(x1*r, y0, z1*r);
            if(smooth) n.push(x1,0,z1); else n.push(xn,0,zn);
            c.push(color[0], color[1], color[2], color[3]);

            // side 2/2
            p.push(x0*r, y1, z0*r);
            if(smooth) n.push(x0,0,z0); else n.push(xn,0,zn);
            c.push(color[0], color[1], color[2], color[3]);

            p.push(x1*r, y1, z1*r);
            if(smooth) n.push(x1,0,z1); else n.push(xn,0,zn);
            c.push(color[0], color[1], color[2], color[3]);

            p.push(x1*r, y0, z1*r);
            if(smooth) n.push(x1,0,z1); else n.push(xn,0,zn);
            c.push(color[0], color[1], color[2], color[3]);

            // top
            p.push(0, y1, 0);
            n.push(0,1,0);
            c.push(color[0], color[1], color[2], color[3]);

            p.push(x1*r, y1, z1*r);
            n.push(0,1,0);
            c.push(color[0], color[1], color[2], color[3]);

            p.push(x0*r, y1, z0*r);
            n.push(0,1,0);
            c.push(color[0], color[1], color[2], color[3]);

            // bottom
            p.push(0, y0, 0);
            n.push(0,-1,0);
            c.push(color[0], color[1], color[2], color[3]);

            p.push(x0*r, y0, z0*r);
            n.push(0,-1,0);
            c.push(color[0], color[1], color[2], color[3]);

            p.push(x1*r, y0, z1*r);
            n.push(0,-1,0);
            c.push(color[0], color[1], color[2], color[3]);

        }

        gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(p), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, normBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(n), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(c), gl.STATIC_DRAW);

        return {
            posBuffer: posBuffer,
            normBuffer: normBuffer,
            colorBuffer: colorBuffer,
            length: p.length/3,
        };
    }

    ///////////////////////////////////////////////////
    // ui helper functions

    document.onkeydown = function(event) {
        for(key in keys) {
            keysDown[key] |= (event.keyCode == keys[key]);
        }
    }

    document.onkeyup = function(event) {
        for(key in keys) {
            keysDown[key] &= (event.keyCode != keys[key]);
        }
    }

    function resize(canvas) {
        // Lookup the size the browser is displaying the canvas.
        var displayWidth  = canvas.clientWidth;
        var displayHeight = canvas.clientHeight;
        // Check if the canvas is not the same size.
        if (canvas.width  != displayWidth || canvas.height != displayHeight) {
            // Make the canvas the same size
            canvas.width  = displayWidth;
            canvas.height = displayHeight;
        }
    }

    ///////////////////////////////////////////////////
    // webgl helper functions

    function createShader(gl, type, source)
    {
        var shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if(gl.getShaderParameter(shader, gl.COMPILE_STATUS))
        {
            return shader;
        }
        var msg = gl.getShaderInfoLog(shader);
        alert('Shader Compile Error:\n' + msg);
        gl.deleteShader(shader);
        throw new Error('Shader compile error');
    }

    function createProgram(gl, vertexShader, fragmentShader)
    {
        var program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if(gl.getProgramParameter(program, gl.LINK_STATUS))
        {
            return program;
        }
        var msg = gl.getProgramInfoLog(program);
        alert('Shader Linker Error:\n' + msg);
        gl.deleteProgram(program);
        throw new Error('Shader linker error');
    }

    function createProgram2d(gl, vertexShader, fragmentShader)
    {
        var program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if(gl.getProgramParameter(program, gl.LINK_STATUS))
        {
            return program;
        }
        var msg = gl.getProgramInfoLog(program);
        alert('Shader Linker Error:\n' + msg);
        gl.deleteProgram(program);
        throw new Error('Shader linker error');
    }


</script>
</html>
