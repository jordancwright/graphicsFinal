<html>
<meta charset="UTF-8"/>
<title>Cube Walking</title>

<link rel="stylesheet" type="text/css" href="cube_walking.css">

<!-- maps are stored in external files -->
<script type="notjs" id="map">
XXXXXXXXXXXXXXXXXXX
X        V        X
X L             L X
X     O     O     X
X                 X
X  O           O  X
X                 X
X     O     O     X
X                 X
XX  C    C   C  XX
XL               LX
XXXXXXXXXXXXXXXXXXX
</script>

<!-- include 3x3 matrix math library -->
<script src="lib/3d-math.js"></script>


<body>
<canvas id="c"></canvas>
<div id="ui"><table>
    <tr><td>Use arrow keys to move.</td></tr>
    <tr><td>fps: <span id="fps">-----</span></td></tr>
    <tr><td><label for="chk">Enable Crosshair</label></td><td><input type="checkbox" id="enablecrosshair" name="chk"></td></tr>
	<tr><td><label for="chk">Enable Fog</label></td><td><input type="checkbox" id="fog" name="chk"></td></tr>
	<tr><td><label for="chk">Enable NPR</label></td><td><input type="checkbox" id="npr" name="chk"></td></tr>
	<tr><td><label for="chk">Do NPR before Fog</label></td><td><input type="checkbox" id="nprBeforeFog" name="chk"></td></tr>
</table></div>
</body>

<!-- shaders to draw 2d crosshair -->


<script type="notjs" id="2d-vertex-shader">
    // an attribute will receive data from a buffer
    attribute vec4 a_position;

    void main() {
        // convert the position from pixels to 0.0 to 1.0
        gl_Position = a_position;
    }

</script>



<script type="notjs" id="2d-fragment-shader">
    // fragment shaders don't have a default precision so we need
    // to pick one. mediump is a good default. It means "medium precision"
    precision mediump float;

    void main() {
    // gl_FragColor is a special variable a fragment shader
        gl_FragColor = vec4(0, 1, 0, 1); // return redish-purple
    }
</script>

<script type="notjs" id="vertex-shader">
    precision mediump float;

    uniform mat4 u_matrixP;         // projection matrix    ( camera -> clip   )
    uniform mat4 u_matrixV;         // view matrix          (  world -> camera )
    uniform mat4 u_matrixM;         // model matrix         (  local -> world  )
    uniform mat4 u_matrixVit;       // inverse-transpose of view matrix
    uniform mat4 u_matrixMit;       // inverse-transpose of model matrix

    attribute vec3 a_pos_local;     // vert position in local space
    attribute vec3 a_norm_local;    // vert normal in local space
    attribute vec4 a_color;         // vert color

    varying vec3 v_pos_world;       // vert position in world space
    varying vec3 v_pos_camera;      // vert position in camera space
    varying vec3 v_norm_world;      // vert normal in world space
    varying vec3 v_norm_camera;     // vert normal in camera space
    varying vec4 v_color;           // vert color

    void main()
    {
        vec4 pw = u_matrixM * vec4(a_pos_local, 1);
        vec4 pc = u_matrixV * pw;
        vec3 nw = normalize((u_matrixMit * vec4(a_norm_local, 0)).xyz);
        vec3 nc = normalize((u_matrixVit * vec4(nw,           0)).xyz);

        gl_Position = u_matrixP * pc;

        v_pos_world   = pw.xyz / pw.w;
        v_pos_camera  = pc.xyz / pc.w;
        v_norm_world  = nw;
        v_norm_camera = nc;
        v_color       = a_color;
    }
</script>

<script type="notjs" id="fragment-shader">
    precision mediump float;

    // NOTE: MAXLIGHTS keyword will be replaced in javascript
    uniform vec3 u_light_pos[MAXLIGHTS];    // position of light
    uniform vec4 u_light_color[MAXLIGHTS];  // light color (rgb) and brightness (alpha)
    uniform vec4 u_light_ambient;           // ambient color (rgb) and brightness (alpha)
    uniform vec4 u_light_torch;             // simulate player holding a torch
	uniform vec3 u_player_loc;				// player position
	uniform bool u_fog;						// fog enabled?
	uniform bool u_npr;						// non-photorealistic rendering enabled?
	uniform bool u_npr_before_fog;			// non-photorealistic rendering before fog?

    varying vec3 v_pos_world;   // vert position in world space
    varying vec3 v_pos_camera;  // vert position in camera space
    varying vec3 v_norm_world;  // vert normal in world space
    varying vec3 v_norm_camera; // vert normal in camera space
    varying vec4 v_color;       // vert color

    void main()
    {
        vec3 kd, ka, kt;
		
		int nonPhoto = 1;
		int fog = 1;
		
		vec4 ambient = u_light_ambient;
		if (nonPhoto == 1) {
			ambient[3] = 0.05;
		} else {
			ambient[3] = 0.02;
		}

        // accumulate diffuse lighting
        kd = vec3(0,0,0);
        for(int i = 0; i < MAXLIGHTS; i++) {
            if(u_light_color[i].a > 0.0) {
                vec3  ldiff = u_light_pos[i] - v_pos_world;         // vector from fragment to light
                float ldist = length(ldiff);                        // distance from fragment to light
                vec3  ldir  = ldiff / ldist;                        // light direction (from fragment to light)
                float ndotl = max(0.0, dot(v_norm_world, ldir));    // fragment normal dot light direction
                kd += u_light_color[i].rgb * (u_light_color[i].a * ndotl / (ldist*ldist));
            }
        }

        // compute ambient lighting
        //ka = u_light_ambient.rgb * u_light_ambient.a;
		ka = vec3(ambient[0], ambient[1], ambient[2]) * ambient[3];

        // simulate torch
        float vdist = length(v_pos_camera);                     // distance from fragment to camera
        vec3  vdir  = -v_pos_camera / vdist;                    // view direction (from fragment to camera)
        float ndotl = max(0.0, dot(v_norm_camera, vdir));       // fragment normal dot light (view) direction
        kt = u_light_torch.rgb * (ndotl * u_light_torch.a / pow(vdist, 1.1));
		float v;
        vec4 color = vec4(v_color.rgb * (kt + ka + kd), v_color.a);
		
		if (u_npr && u_npr_before_fog) {
			v = sqrt(color[0] + color[1] + color[2]);
			v = pow(floor(v*5.0)/5.0, 2.0);
			color = normalize(color) * v;
			color[3] = 1.0;
		}
		
		if(u_fog) {
			float radius = 20.0;
			float fogIntensity = 0.2;
			vec3 fogCenter = vec3(10.0, 0.0, 5.0);
			vec3 d = normalize(v_pos_world - u_player_loc); 
			vec3 E = d * dot(fogCenter - u_player_loc, d) + u_player_loc;
			float a = 1.0;
			float b = dot(2.0 * d, u_player_loc - fogCenter);
			float c = pow(length(u_player_loc - fogCenter), 2.0) - pow(radius, 2.0);
			float determinant = pow(b, 2.0) - (4.0*a*c);
			float fog = pow(1.0 - (length(E - fogCenter)/radius), 0.3);
			float tPlus = (-b + sqrt(determinant)) / (2.0*a);
			float tMinus = (-b - sqrt(determinant)) / (2.0*a);
			for (int i = 0; i < 3; i++) {
				if (fog > 0.0) {
					if(length(u_player_loc - fogCenter) < radius) { //If the player is in the fog, then apply fog
						color[i] = color[i] + fog * fogIntensity;
					} else if (length(v_pos_world - fogCenter) < radius) { // if an object is in the fog, then apply fog
						color[i] = color[i] + fog * fogIntensity;
					} else if (determinant > 0.0) { //if the ray from the player to the frag intersects with the fog
						if((tPlus < length(u_player_loc - v_pos_world) && tPlus > 0.0) || (tMinus < length(u_player_loc - v_pos_world) && tMinus > 0.0)) { //if the object is behind the fog
							color[i] = color[i] + fog * fogIntensity;
						}
					}
				}
			}
		}
		
		if (u_npr && !u_npr_before_fog) {
			v = sqrt(color[0] + color[1] + color[2]);
			v = pow(floor(v*5.0)/5.0, 2.0);
			color = normalize(color) * v;
			color[3] = 1.0;
		}
		gl_FragColor = vec4(color.rgb, vdist/100.0);
    }
</script>

<script type="notjs" id="depth-blur-fragment-shader">

    precision mediump float;

    varying vec2 v_texcoord;
    uniform sampler2D uSampler;
    uniform sampler2D uSampler2;

    vec2 uv2pix(vec2 uv) {
        return uv * 2048.0;
    }

    vec2 pix2uv(vec2 pix) {
        return pix / 2048.0;
    }

    void main(void) {
        float infocusdist = 0.1;  //5 walls space
        float infocuspower = 15.0; // larger number tightens what's in focus

        vec4 textureColor1 = texture2D(uSampler, pix2uv(uv2pix(v_texcoord) + vec2(-2,-2)));
        vec4 textureColor2 = texture2D(uSampler, pix2uv(uv2pix(v_texcoord) + vec2(-2,0)));
        vec4 textureColor3 = texture2D(uSampler, pix2uv(uv2pix(v_texcoord) + vec2(-2,2)));
        vec4 textureColor4 = texture2D(uSampler, pix2uv(uv2pix(v_texcoord) + vec2(0,-2)));
        vec4 textureColor5 = texture2D(uSampler, pix2uv(uv2pix(v_texcoord) + vec2(0,0)));
        vec4 textureColor6 = texture2D(uSampler, pix2uv(uv2pix(v_texcoord) + vec2(0,2)));
        vec4 textureColor7 = texture2D(uSampler, pix2uv(uv2pix(v_texcoord) + vec2(2,-2)));
        vec4 textureColor8 = texture2D(uSampler, pix2uv(uv2pix(v_texcoord) + vec2(2,0)));
        vec4 textureColor9 = texture2D(uSampler, pix2uv(uv2pix(v_texcoord) + vec2(2,2)));

        vec4 textureColor = (textureColor1 + textureColor2 + textureColor3 + textureColor4 +textureColor5 + textureColor6 + textureColor7 + textureColor8 + textureColor9)/9.0;

        float distd = textureColor5.a;
        float blend = pow(1.0 - clamp(abs(infocusdist - distd), 0.0, 1.0), infocuspower);     

        gl_FragColor = vec4(textureColor5.rgb * blend + textureColor.rgb * (1.0-blend), 1.0);
    }

</script>

<script type="notjs" id="depth-blur-vertex-shader">
    // an attribute will receive data from a buffer
    //attribute vec4 a_position;
    attribute vec2 a_position;

    uniform vec2 u_resolution;

    varying vec2 v_texcoord;



    void main() {
        // convert the position from pixels to 0.0 to 1.0
        //v_texcoord = a_position.xy;

        // convert the position from pixels to 0.0 to 1.0

        vec2 zeroToOne = a_position / u_resolution;
        // convert from 0->1 to 0->2
        vec2 zeroToTwo = zeroToOne * 2.0;
        // convert from 0->2 to -1->+1 (clipspace)
        vec2 clipSpace = zeroToTwo - 1.0;

        v_texcoord = a_position * u_resolution/2048.0;

        gl_Position = vec4(a_position * 2.0 - 1.0, 0, 1);
    }

</script>

<script>
    const MAXLIGHTS = 8;
    const MAPLOAD = "map1";

    //////////////////////////////
    // set up webgl

    var canvas = document.getElementById("c");
    var gl = canvas.getContext("webgl", {antialias:true});
    var depthTextureExt = gl.getExtension("WEBKIT_WEBGL_depth_texture"); // Or browser-appropriate prefix
    if(!depthTextureExt) { throw new Error('extension compile error'); }

    gl.enable( gl.DEPTH_TEST );
    gl.depthFunc( gl.LESS );
    gl.enable( gl.CULL_FACE );
    gl.enable( gl.BLEND );
    gl.blendEquation( gl.FUNC_ADD );
    gl.blendFunc( gl.ONE, gl.ZERO );

//////////DEPTH BLUR/////////
    var depthBlurFrameBuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, depthBlurFrameBuffer);
    depthBlurFrameBuffer.width = 2048;
    depthBlurFrameBuffer.height = 2048;

    var depthBlurTexture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, depthBlurTexture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    //gl.generateMipmap(gl.TEXTURE_2D);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, depthBlurFrameBuffer.width, depthBlurFrameBuffer.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

    var depthTexture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, depthTexture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.DEPTH_COMPONENT, depthBlurFrameBuffer.width, depthBlurFrameBuffer.height, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_SHORT, null);

    var renderbuffer = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, depthBlurFrameBuffer.width, depthBlurFrameBuffer.height);

    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, depthBlurTexture, 0);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture, 0);
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);

    gl.bindTexture(gl.TEXTURE_2D, null);
    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
//////////END DEPTH BLUR/////////

    var vertShaderSrc = document.getElementById("vertex-shader").text.replace(/MAXLIGHTS/g,MAXLIGHTS);
    var fragShaderSrc = document.getElementById("fragment-shader").text.replace(/MAXLIGHTS/g,MAXLIGHTS);
    var vertShader = createShader(gl, gl.VERTEX_SHADER,   vertShaderSrc);
    var fragShader = createShader(gl, gl.FRAGMENT_SHADER, fragShaderSrc);
    var program = createProgram(gl, vertShader, fragShader);
    gl.useProgram(program);

//////////DEPTH BLUR/////////
    var depthVertexShaderSrc = document.getElementById("depth-blur-vertex-shader").text;
    var depthFragShaderSrc = document.getElementById("depth-blur-fragment-shader").text;
    var depthFragShader = createShader(gl, gl.FRAGMENT_SHADER, depthFragShaderSrc);
    var depthVertexShader = createShader(gl, gl.VERTEX_SHADER, depthVertexShaderSrc);
    var shaderProgram = createProgram(gl, depthVertexShader, depthFragShader);
//////////END DEPTH BLUR/////////

    var posLocation   = gl.getAttribLocation(program, "a_pos_local");
    var normLocation  = gl.getAttribLocation(program, "a_norm_local");
    var colorLocation = gl.getAttribLocation(program, "a_color");

    var matrixPLocation = gl.getUniformLocation(program, "u_matrixP");
    var matrixMLocation = gl.getUniformLocation(program, "u_matrixM");
    var matrixVLocation = gl.getUniformLocation(program, "u_matrixV");
    var matrixMitLocation  = gl.getUniformLocation(program, "u_matrixMit");
    var matrixVitLocation  = gl.getUniformLocation(program, "u_matrixVit");

    var lightPosLocations = [];
    var lightColLocations = [];
    for(var i = 0; i < MAXLIGHTS; i++) {
        lightPosLocations.push(gl.getUniformLocation(program, "u_light_pos[" + i + "]"));
        lightColLocations.push(gl.getUniformLocation(program, "u_light_color[" + i + "]"));
    }
    var lightAmbLocation = gl.getUniformLocation(program, "u_light_ambient");
    var lightTorLocation = gl.getUniformLocation(program, "u_light_torch");

    gl.enableVertexAttribArray(posLocation);
    gl.enableVertexAttribArray(normLocation);
    gl.enableVertexAttribArray(colorLocation);

    var TwoDVertShaderSrc = document.getElementById("2d-vertex-shader").innerHTML;
    var TwoDFragShaderSrc = document.getElementById("2d-fragment-shader").innerHTML;
    var TwoDVertShader = createShader(gl, gl.VERTEX_SHADER, TwoDVertShaderSrc);
    var TwoDFragShader = createShader(gl, gl.FRAGMENT_SHADER, TwoDFragShaderSrc);
    var TwoDProgram = createProgram2d(gl, TwoDVertShader, TwoDFragShader);


    gl.useProgram(TwoDProgram);
    var positionAttributeLocation2d = gl.getAttribLocation(TwoDProgram, "a_position");

    gl.enableVertexAttribArray(positionAttributeLocation2d);


    var positionBuffer2d = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer2d);

    var positions2d = [
        //top
        -0.007, 0.1,
        -0.007, 0.03,
        0.007, 0.03,
        -0.007, 0.1,
        0.007, 0.1,
        0.007, 0.03,
        //left
        -0.1, -0.007,
        -0.03, -0.007,
        -0.03, 0.007,
        -0.1, -0.007,
        -0.1, 0.007,
        -0.03, 0.007,
        //right
        0.1, -0.007,
        0.03, -0.007,
        0.03, 0.007,
        0.1, -0.007,
        0.1, 0.007,
        0.03, 0.007,
        //bottom
        -0.007, -0.1,
        -0.007, -0.03,
        0.007, -0.03,
        -0.007, -0.1,
        0.007, -0.1,
        0.007, -0.03,
    ];

    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions2d), gl.STATIC_DRAW);

//////////DEPTH BLUR/////////
    gl.useProgram(shaderProgram);
    var blurAttributeLocation = gl.getAttribLocation(shaderProgram, "a_position");
    var resolutionUniformLocation = gl.getUniformLocation(shaderProgram, "u_resolution");

    gl.enableVertexAttribArray(blurAttributeLocation);

     var blurTexturePositions = [
        0.0, 0.0,
        0.0, 1.0,
        1.0, 0.0,
        1.0, 0.0,
        1.0, 1.0,
        0.0, 1.0
    ];

    var blurBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, blurBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(blurTexturePositions), gl.STATIC_DRAW);

    // set the resolution
//////////END DEPTH BLUR/////////

    ///////////////////////////
    // game info
    // game states
    var prevTime = 0;
    var frames = 0, prevFramesTime = 0;
    var keysDown = [];
    var keys = { // see http://www.asquare.net/javascript/tests/KeyCode.html
        up:    38,
        down:  40,
        left:  37,
        right: 39,
    };
    var drawFloor = true, drawCeiling = true;

    // player and torch states
    var player = { loc:[0,0,0], fwdSpeed:0, dir:0, dirSpeed:0, fov:60, clip:[0.01,100] };
    var torch = { val: 1.0, range:[0.2,1.5], color:[1.0,0.7,0.4], blend:0.9 };

    // drawable objects
    var objectWall    = generateCubeObject(1.0);
    var objectTree    = generateCylinderObject(8, [0.2,0.5,0.2,1.0], false, 0.2, -1.0, 0.8);
    var objectTable   = generateCylinderObject(8, [0.7,0.7,0.7,1.0], false, 1.0, -1.0, -0.2);
    var objectLight   = generateCylinderObject(8, [0.7,1.0,0.7,1.0], false, 0.2,  0.9, 1.0);
    var objectFloor   = generateQuadObject([0,0,0], [0.7,0.7,0.7,1.0], [1,0,0], [0,0,1], [0, 1,0], 1);
    var objectCeiling = generateQuadObject([0,0,0], [0.5,0.5,0.5,1.0], [-1,0,0], [0,0,1], [0,-1,0], 1);
        var objectConeHD = generateConeObject(150,[0,1,0,1],false,.5,-1,1)
    ///////////////////////////
    // map stuff
    // x increases west-to-east, z increases north-to-south, and y increases floor-to-ceiling
    // player start    V : facing south, > : east, ^ : north, < : west
    // obstacle info   X : wall, O : cylinder, o : tree
    // lighting info   L : light

    var map = document.getElementById("map").text.split("\n");

    // convenient dictionaries for converting map symbols to drawable objects or player start directions
    var typeToObject = {
        "X": objectWall,
        "O": objectTable,
        "o": objectTree,
        "L": objectLight,
        "C": objectConeHD,
    };
    var typeToDirection = {
        "V": 0,
        ">": 1,
        "^": 2,
        "<": 3
    };
    var typeOfObstacles = ["X","O","o"];

    // gather info about map
    var mapSize = map.length;
    var drawables = []; // a list of drawable objects
    var lights = [];    // all the lights in the scene (up to MAXLIGHTS)
    for(var i = 0; i < map.length; i++) {
        var maprow = map[i];
        mapSize = Math.max(mapSize, maprow.length);
        for(var j = 0; j < maprow.length; j++) {
            var pos = [j*2, 0, i*2];

            // drawable objects
            if(maprow[j] in typeToObject) {
                drawables.push({
                    loc: pos,
                    type: maprow[j],
                    object: typeToObject[maprow[j]],
                });
            }

            // lights
            if(maprow[j] == "L") {
                if(lights.length < MAXLIGHTS) {
                    lights.push({
                        loc: [pos[0],0.88,pos[2]],
                        color: [1,1,1,2],
                    });
                } else {
                    console.log("too many lights!");
                }
            }

            // player start location and orientation
            if(maprow[j] in typeToDirection) {
                player.loc = pos;
                player.dir = typeToDirection[maprow[j]] * Math.PI / 2.0;
            }
        }
    }

    ///////////////////////////////////////////
    // game update and render

    requestAnimationFrame(update);

    function update(currTime)
    {
        var enabledcrosshair = document.getElementById("enablecrosshair").checked;        
        currTime *= 0.001;
        var deltaTime = Math.min(currTime - prevTime, 0.25);
        prevTime = currTime;

        frames++;
        if(prevFramesTime == 0) prevFramesTime = currTime;
        if(frames > 100) {
            var framesTime = currTime - prevFramesTime;
            var fps = frames / framesTime;
            frames = 0;
            prevFramesTime = currTime;
            var fpsText = "" + Math.floor(fps * 100.0) / 100.0;
            fpsText += (fpsText.indexOf('.')==-1 ? '.' : '') + "000000";
            document.getElementById('fps').innerHTML = fpsText.slice(0,5);
        }

        // handle player movement
        if(keysDown.left) {
            player.dirSpeed += 15.0 * deltaTime;
        }
        if(keysDown.right) {
            player.dirSpeed -= 15.0 * deltaTime;
        }
        if(keysDown.up) {
            player.fwdSpeed += 40.0 * deltaTime;
        }
        if(keysDown.down) {
            player.fwdSpeed -= 40.0 * deltaTime;
        }
        player.loc[0] += player.fwdSpeed * Math.sin(player.dir) * deltaTime;
        player.loc[2] += player.fwdSpeed * Math.cos(player.dir) * deltaTime;
        player.dir += player.dirSpeed * deltaTime;
        player.fwdSpeed *= Math.pow(0.001, deltaTime);
        player.dirSpeed *= Math.pow(0.001, deltaTime);

        // check if player collides with obstacle
        var hitNorth = hitObstacle(player.loc[0], player.loc[1], player.loc[2] - 0.2);
        var hitSouth = hitObstacle(player.loc[0], player.loc[1], player.loc[2] + 0.2);
        var hitEast  = hitObstacle(player.loc[0] - 0.2, player.loc[1], player.loc[2]);
        var hitWest  = hitObstacle(player.loc[0] + 0.2, player.loc[1], player.loc[2]);
        if(hitNorth) {
            player.loc[2] = Math.round(player.loc[2]) + 0.2;
        }
        if(hitSouth) {
            player.loc[2] = Math.round(player.loc[2]) - 0.2;
        }
        if(hitEast) {
            player.loc[0] = Math.round(player.loc[0]) + 0.2;
        }
        if(hitWest) {
            player.loc[0] = Math.round(player.loc[0]) - 0.2;
        }
        // warning: the corner collision detection is not great
        var hitCorner = false;
        var hitOff = [0,0];
        var d = 0.141; // Math.sqrt((0.2*0.2) / 2)
        if(!hitNorth && !hitEast) {
            if(hitObstacle(player.loc[0]+d, player.loc[1], player.loc[2]-d)) {
                hitCorner = true;
                hitOff = [ d,-d];
            }
        }
        if(!hitNorth && !hitWest) {
            if(hitObstacle(player.loc[0]-d, player.loc[1], player.loc[2]-d)) {
                hitCorner = true;
                hitOff = [-d,-d];
            }
        }
        if(!hitSouth && !hitEast) {
            if(hitObstacle(player.loc[0]+d, player.loc[1], player.loc[2]+d)) {
                hitCorner = true;
                hitOff = [ d, d];
            }
        }
        if(!hitSouth && !hitWest) {
            if(hitObstacle(player.loc[0]-d, player.loc[1], player.loc[2]+d)) {
                hitCorner = true;
                hitOff = [-d, d];
            }
        }
        if(hitCorner) {
            var hx = Math.round(player.loc[0] + hitOff[0]), hz = Math.round(player.loc[2] + hitOff[1]);
            var dx = player.loc[0] - hx, dz = player.loc[2] - hz;
            var dl = Math.sqrt(dx*dx + dz*dz);
            player.loc[0] = hx + d * dx/dl;
            player.loc[2] = hz + d * dz/dl;
        }


        // resize and redraw the canvas!!
        resize(canvas);

//////////DEPTH BLUR/////////
        gl.bindFramebuffer(gl.FRAMEBUFFER, depthBlurFrameBuffer);
        gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
//////////END DEPTH BLUR/////////

        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        gl.useProgram(program);
		
		var fog = gl.getUniformLocation(program, "u_fog");
		gl.uniform1i(fog, document.getElementById("fog").checked);
		var npr = gl.getUniformLocation(program, "u_npr");
		gl.uniform1i(npr, document.getElementById("npr").checked);
		var nprBeforeFog = gl.getUniformLocation(program, "u_npr_before_fog");
		gl.uniform1i(nprBeforeFog, document.getElementById("nprBeforeFog").checked);
		
		var playerLocation = gl.getUniformLocation(program, "u_player_loc");
		gl.uniform3f(playerLocation, player.loc[0], player.loc[1], player.loc[2]);
		
        var xformP    = m4.perspective(player.fov * Math.PI / 180.0, gl.canvas.width / gl.canvas.height, player.clip[0], player.clip[1]);
        // note: lookAt returns the inverse of the view xform matrix, so we need to invert
        var xformVinv = m4.lookAt(player.loc, [player.loc[0]+Math.sin(player.dir), player.loc[1], player.loc[2]+Math.cos(player.dir)], [0,1,0]);
        var xformV    = m4.inverse(xformVinv);

        gl.uniformMatrix4fv(matrixPLocation,   false, xformP);
        gl.uniformMatrix4fv(matrixVLocation,   false, xformV);
        gl.uniformMatrix4fv(matrixVitLocation, false, m4.transpose(xformVinv));

        for(var i = 0; i < lights.length; i++) {
            gl.uniform3fv(lightPosLocations[i], lights[i].loc);
            gl.uniform4fv(lightColLocations[i], lights[i].color);
        }

//AMOUNT OF AMBIENT LIGHT
        //gl.uniform4f(lightAmbLocation, 1.0, 1.0, 1.0, 0.5);
        gl.uniform4f(lightAmbLocation, 1.0, 1.0, 1.0, 0.01);

        var torchNew = torch.range[0] + (torch.range[1] - torch.range[0]) * Math.random();
        torch.val = torch.val * torch.blend + torchNew * (1.0 - torch.blend);
        gl.uniform4f(lightTorLocation, torch.color[0], torch.color[1], torch.color[2], torch.val);

        if(drawFloor)
        {
            var xformM = m4.translation(mapSize, -1, mapSize);
            xformM = m4.scale(xformM, mapSize, mapSize, mapSize);
            var xformMinv = m4.identity(); // ignore scaling and translation
            gl.uniformMatrix4fv(matrixMLocation,   false, xformM);
            gl.uniformMatrix4fv(matrixMitLocation, false, m4.transpose(xformMinv));
            drawObject(objectFloor);
        }

        if(drawCeiling)
        {
            var xformM = m4.translation(mapSize, 1, mapSize);
            xformM = m4.scale(xformM, mapSize, mapSize, mapSize);
            var xformMinv = m4.identity(); // ignore scaling and translation
            gl.uniformMatrix4fv(matrixMLocation,   false, xformM);
            gl.uniformMatrix4fv(matrixMitLocation, false, m4.transpose(xformMinv));
            drawObject(objectCeiling);
        }

        // draw *all* drawable objects (not terribly efficient!)
        for(i = 0; i < drawables.length; i++) {
            var drawable = drawables[i];
            // calculate transformation and its inverse
            var xformM    = m4.translation( drawable.loc[0],  drawable.loc[1],  drawable.loc[2]);
            var xformMinv = m4.translation(-drawable.loc[0], -drawable.loc[1], -drawable.loc[2]);
            gl.uniformMatrix4fv(matrixMLocation,   false, xformM);
            gl.uniformMatrix4fv(matrixMitLocation, false, m4.transpose(xformMinv));
            drawObject(drawable.object);
        }

//////////DEPTH BLUR/////////
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);

		gl.disable( gl.DEPTH_TEST );
        gl.disable( gl.CULL_FACE );
        gl.useProgram(shaderProgram);
        gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, depthBlurTexture);
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, depthTexture);
        
        //gl.bindTexture(gl.TEXTURE_2D, depthTexture);

        gl.uniform1i(gl.getUniformLocation(shaderProgram,"uSampler"), 0);
        gl.uniform1i(gl.getUniformLocation(shaderProgram,"uSampler2"), 1);

        gl.bindBuffer(gl.ARRAY_BUFFER, blurBuffer);
        var size = 2;          // 2 components per iteration
        var type = gl.FLOAT;   // the data is 32bit floats
        var normalize = false; // don't normalize the data
        var stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position
        var offset = 0;        // start at the beginning of the buffer
        gl.vertexAttribPointer(blurAttributeLocation, size, type, normalize, stride, offset);

        gl.drawArrays(gl.TRIANGLES, 0, 6);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, null);
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, null);
//////////END DEPTH BLUR/////////

		//crosshair starts here
        if(enabledcrosshair){
            gl.useProgram(TwoDProgram);

            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer2d);

            var size = 2;          // 2 components per iteration
            var type = gl.FLOAT;   // the data is 32bit floats
            var normalize = false; // don't normalize the data
            var stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position
            var offset = 0;        // start at the beginning of the buffer
            gl.vertexAttribPointer(positionAttributeLocation2d, size, type, normalize, stride, offset);

            var primitiveType = gl.TRIANGLES;
            var offset = 0;
            var count = 24;
            gl.drawArrays(primitiveType, offset, count);
        }

		gl.enable( gl.DEPTH_TEST );
        gl.enable( gl.CULL_FACE );

        requestAnimationFrame(update);
    }

    function hitObstacle(x,y,z)
    {
        var i = Math.round(z/2), j = Math.round(x/2);
        if(i < 0 || j < 0 || i >= map.length || j >= map[i].length) return false;
        return typeOfObstacles.indexOf(map[i][j]) != -1;
    }

    function drawObject(object)
    {
        // setup position buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, object.posBuffer);
        var size = 3;
        var type = gl.FLOAT;
        var normalize = false;
        var stride = 0;
        var offset = 0;
        gl.vertexAttribPointer(posLocation, size, type, normalize, stride, offset);

        // setup normal buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, object.normBuffer);
        var size = 3;
        var type = gl.FLOAT;
        var normalize = true;
        var stride = 0;
        var offset = 0;
        gl.vertexAttribPointer(normLocation, size, type, normalize, stride, offset);

        // setup color buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, object.colorBuffer);
        var size = 4;
        var type = gl.FLOAT;
        var normalize = false;
        var stride = 0;
        var offset = 0;
        gl.vertexAttribPointer(colorLocation, size, type, normalize, stride, offset);

        // draw the triangles!
        var primitiveType = gl.TRIANGLES;
        var offset = 0;
        gl.drawArrays(primitiveType, offset, object.length);
    }


    /////////////////////////////////////
    // generator helper functions

    function generateCubeObject(s)
    {
        var posBuffer   = gl.createBuffer();
        var normBuffer  = gl.createBuffer();
        var colorBuffer = gl.createBuffer();

        gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -s, -s, -s,   -s,  s, -s,    s, -s, -s, // north face
             s, -s, -s,   -s,  s, -s,    s,  s, -s,
            -s, -s,  s,    s, -s,  s,   -s,  s,  s, // south face
             s, -s,  s,    s,  s,  s,   -s,  s,  s,
            -s, -s, -s,   -s, -s,  s,   -s,  s, -s, // west face
            -s,  s, -s,   -s, -s,  s,   -s,  s,  s,
             s, -s, -s,    s,  s, -s,    s, -s,  s, // east face
             s,  s, -s,    s,  s,  s,    s, -s,  s,
            ]), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, normBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
             0,  0, -1,    0,  0, -1,    0,  0, -1, // north face
             0,  0, -1,    0,  0, -1,    0,  0, -1,
             0,  0,  1,    0,  0,  1,    0,  0,  1, // south face
             0,  0,  1,    0,  0,  1,    0,  0,  1,
            -1,  0,  0,   -1,  0,  0,   -1,  0,  0, // west face
            -1,  0,  0,   -1,  0,  0,   -1,  0,  0,
             1,  0,  0,    1,  0,  0,    1,  0,  0, // east face
             1,  0,  0,    1,  0,  0,    1,  0,  0,
            ]), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            1, 0, 0, 1,   1, 0, 0, 1,   1, 0, 0, 1, // north face
            1, 0, 0, 1,   1, 0, 0, 1,   1, 0, 0, 1,
            0, 1, 0, 1,   0, 1, 0, 1,   0, 1, 0, 1, // south face
            0, 1, 0, 1,   0, 1, 0, 1,   0, 1, 0, 1,
            0, 0, 1, 1,   0, 0, 1, 1,   0, 0, 1, 1, // west face
            0, 0, 1, 1,   0, 0, 1, 1,   0, 0, 1, 1,
            1, 0, 1, 1,   1, 0, 1, 1,   1, 0, 1, 1, // east face
            1, 0, 1, 1,   1, 0, 1, 1,   1, 0, 1, 1,
            ]), gl.STATIC_DRAW);

        return {
            posBuffer: posBuffer,
            normBuffer: normBuffer,
            colorBuffer: colorBuffer,
            length: 6*4,
        };
    }

    function generateQuadObject(loc, color, u, v, norm, size)
    {
        var posBuffer   = gl.createBuffer();
        var normBuffer  = gl.createBuffer();
        var colorBuffer = gl.createBuffer();

        var x = loc[0], y = loc[1], z = loc[2];
        var ux = u[0]*size, uy = u[1]*size, uz = u[2]*size;
        var vx = v[0]*size, vy = v[1]*size, vz = v[2]*size;

        var x0 = x - ux - vx, y0 = y - uy - vy, z0 = z - uz - vz;
        var x1 = x + ux - vx, y1 = y + uy - vy, z1 = z + uz - vz;
        var x2 = x + ux + vx, y2 = y + uy + vy, z2 = z + uz + vz;
        var x3 = x - ux + vx, y3 = y - uy + vy, z3 = z - uz + vz;

        var nx = norm[0], ny = norm[1], nz = norm[2];
        var r = color[0], g = color[1], b = color[2], a = color[3];

        gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            x0, y0, z0,   x3, y3, z3,   x1, y1, z1,
            x3, y3, z3,   x2, y2, z2,   x1, y1, z1,
            ]), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, normBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            nx, ny, nz,   nx, ny, nz,   nx, ny, nz,
            nx, ny, nz,   nx, ny, nz,   nx, ny, nz,
            ]), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            r,g,b,a,   r,g,b,a,   r,g,b,a,
            r,g,b,a,   r,g,b,a,   r,g,b,a,
            ]), gl.STATIC_DRAW);

        return {
            posBuffer: posBuffer,
            normBuffer: normBuffer,
            colorBuffer: colorBuffer,
            length: 6,
        };
    }
function generateConeObject(count, color, smooth, r, y0, y1) // r = radius of cone,  y0 = bottom, y1 = top
    {  
        var posBuffer   = gl.createBuffer(); // on graphics card, we will put data in them
        var normBuffer  = gl.createBuffer();
        var colorBuffer = gl.createBuffer();
       
        var p = []; //collecting position normal, color info
        var n = [];
        var c = [];
           var angle = 360/count
            var currentAngle = 0
       
        for(var i = 0; i < count; i++) // iterating through vertices
        {
        // -1 y value if on the ground
                // y1 (0) = center
           
            var angleInRadians0 =  currentAngle * (Math.PI / 180.0) // angle should be in radians
            var angleInRadians1 =  (currentAngle+angle) * (Math.PI / 180.0) // angle should be in radians
               
        var angleInRadiansN = (angleInRadians0 + angleInRadians1) / 2;
            var x0 = Math.cos(angleInRadians0), z0 = Math.sin(angleInRadians0);
            var x1 = Math.cos(angleInRadians1), z1 = Math.sin(angleInRadians1);
            var xn = Math.cos(angleInRadians0), zn = Math.sin(angleInRadians0);
           
            var height = y1 -y0;
            var phi = Math.atan2(height,r);
            var psi = (Math.PI / 2.0)- phi;
           
            var normx = (Math.cos(psi)* Math.cos(angleInRadiansN));
            var normy = Math.sin(psi);
            var normz = (Math.cos(psi)*Math.sin(angleInRadiansN));
       
               
        // side 1/2
        //counterclock wise for the object to space us
            p.push(x0*r, y0, z0*r);
            if(smooth) n.push(x0,0,z0); else n.push(normx, normy, normz); // push data points on for normals
            c.push(color[0], color[1], color[2], color[3]);
           
           
           
            p.push(0, y1, 0);
            if(smooth) n.push(0,0,0); else n.push(normx,normy,normz);
            c.push(color[0], color[1], color[2], color[3]);
           
            p.push(x1*r, y0, z1*r);
            if(smooth) n.push(x1,0,z1); else n.push(normx,normy,normz);
            c.push(color[0], color[1], color[2], color[3]);
           
 
            p.push(0, y0, 0);
            n.push(0,-1,0);
            c.push(color[0], color[1], color[2], color[3]);
           
             p.push(x0*r, y0, z0*r);
            n.push(0,-1,0);
            c.push(color[0], color[1], color[2], color[3]);
           
               p.push(x1*r, y0, z1*r);
            n.push(0,-1,0);
            c.push(color[0], color[1], color[2], color[3]);
         
             
            currentAngle += angle;        
        }
       
        gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(p), gl.STATIC_DRAW); // points get pushed into buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, normBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(n), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(c), gl.STATIC_DRAW);
       
        return {
            posBuffer: posBuffer,
            normBuffer: normBuffer,
            colorBuffer: colorBuffer,
            length: p.length/3, //sent to graphic card, so the graphic card can render
        };
    }
    function generateCylinderObject(count, color, smooth, r, y0, y1)
    {
        var posBuffer   = gl.createBuffer();
        var normBuffer  = gl.createBuffer();
        var colorBuffer = gl.createBuffer();

        var p = [];
        var n = [];
        var c = [];

        for(var i = 0; i < count; i++)
        {
            var r0 = (i + 0.0) / count * Math.PI * 2.0;
            var r1 = (i + 1.0) / count * Math.PI * 2.0;
            var rn = (i + 0.5) / count * Math.PI * 2.0;
            var x0 = Math.cos(r0), z0 = Math.sin(r0);
            var x1 = Math.cos(r1), z1 = Math.sin(r1);
            var xn = Math.cos(rn), zn = Math.sin(rn);

            // side 1/2
            p.push(x0*r, y0, z0*r);
            if(smooth) n.push(x0,0,z0); else n.push(xn,0,zn);
            c.push(color[0], color[1], color[2], color[3]);

            p.push(x0*r, y1, z0*r);
            if(smooth) n.push(x0,0,z0); else n.push(xn,0,zn);
            c.push(color[0], color[1], color[2], color[3]);

            p.push(x1*r, y0, z1*r);
            if(smooth) n.push(x1,0,z1); else n.push(xn,0,zn);
            c.push(color[0], color[1], color[2], color[3]);

            // side 2/2
            p.push(x0*r, y1, z0*r);
            if(smooth) n.push(x0,0,z0); else n.push(xn,0,zn);
            c.push(color[0], color[1], color[2], color[3]);

            p.push(x1*r, y1, z1*r);
            if(smooth) n.push(x1,0,z1); else n.push(xn,0,zn);
            c.push(color[0], color[1], color[2], color[3]);

            p.push(x1*r, y0, z1*r);
            if(smooth) n.push(x1,0,z1); else n.push(xn,0,zn);
            c.push(color[0], color[1], color[2], color[3]);

            // top
            p.push(0, y1, 0);
            n.push(0,1,0);
            c.push(color[0], color[1], color[2], color[3]);

            p.push(x1*r, y1, z1*r);
            n.push(0,1,0);
            c.push(color[0], color[1], color[2], color[3]);

            p.push(x0*r, y1, z0*r);
            n.push(0,1,0);
            c.push(color[0], color[1], color[2], color[3]);

            // bottom
            p.push(0, y0, 0);
            n.push(0,-1,0);
            c.push(color[0], color[1], color[2], color[3]);

            p.push(x0*r, y0, z0*r);
            n.push(0,-1,0);
            c.push(color[0], color[1], color[2], color[3]);

            p.push(x1*r, y0, z1*r);
            n.push(0,-1,0);
            c.push(color[0], color[1], color[2], color[3]);

        }

        gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(p), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, normBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(n), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(c), gl.STATIC_DRAW);

        return {
            posBuffer: posBuffer,
            normBuffer: normBuffer,
            colorBuffer: colorBuffer,
            length: p.length/3,
        };
    }

    ///////////////////////////////////////////////////
    // ui helper functions

    document.onkeydown = function(event) {
        for(key in keys) {
            keysDown[key] |= (event.keyCode == keys[key]);
        }
    }

    document.onkeyup = function(event) {
        for(key in keys) {
            keysDown[key] &= (event.keyCode != keys[key]);
        }
    }

    function resize(canvas) {
        // Lookup the size the browser is displaying the canvas.
        var displayWidth  = canvas.clientWidth;
        var displayHeight = canvas.clientHeight;
        // Check if the canvas is not the same size.
        if (canvas.width  != displayWidth || canvas.height != displayHeight) {
            // Make the canvas the same size
            canvas.width  = displayWidth;
            canvas.height = displayHeight;
        }
    }

    ///////////////////////////////////////////////////
    // webgl helper functions

    function createShader(gl, type, source)
    {
        var shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if(gl.getShaderParameter(shader, gl.COMPILE_STATUS))
        {
            return shader;
        }
        var msg = gl.getShaderInfoLog(shader);
        alert('Shader Compile Error:\n' + msg);
        gl.deleteShader(shader);
        throw new Error('Shader compile error');
    }

    function createProgram(gl, vertexShader, fragmentShader)
    {
        var program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if(gl.getProgramParameter(program, gl.LINK_STATUS))
        {
            return program;
        }
        var msg = gl.getProgramInfoLog(program);
        alert('Shader Linker Error:\n' + msg);
        gl.deleteProgram(program);
        throw new Error('Shader linker error');
    }

    function createProgram2d(gl, vertexShader, fragmentShader)
    {
        var program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if(gl.getProgramParameter(program, gl.LINK_STATUS))
        {
            return program;
        }
        var msg = gl.getProgramInfoLog(program);
        alert('Shader Linker Error:\n' + msg);
        gl.deleteProgram(program);
        throw new Error('Shader linker error');
    }


</script>
</html>